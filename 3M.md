[TOC]



### 1 接收端处理思路

#### 1.1 Tag 实际反射速率

接收端采样率为20Mhz的情况下

每个符号的采样点数平均为为：$6.9$

实际 Tag 反射速率为：$1/(6.9 * 1/20)= 2.9MHz$ 

> * 匹配滤波的抽头长度：  7
>
> * 符号同步的初始符号周期： 7

接收信号：

![image-20210926212234004](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926212234004.png)





#### 1.2 为何不用原来的接收端处理思路

> 重写了接收端处流流程，具体见第二部分

- 下面分析 直接使用原来的接收端处理思路 的缺点：

##### （1）陷波滤波器的局限：

陷波滤波器在处理有较长水平区间的信号时，会出现问题；

尽管已经将陷波滤波器的延迟线长度调整为128（减小DC 陷波的宽度，原来FM0 是32即可满足要求）

效果如下图所示：依然不好

![image-20210926210920276](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926210920276.png)

> 改用：减去均值法 去除直流。
>
> 但是：信噪比差时，受噪声和自干扰影响很大，性能远不如陷波滤波器





##### （2）AGC 使得信号变形

直接看效果图

![image-20210926211324254](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926211324254.png)

导致后面符号同步效果也不好

> 第二部分提出一种新的AGC的方式，完美解决该问题
>
> 并可替代之前FM0信号的AGC (还未尝试)







### 2 详尽接收端处理流程

#### 2.1 匹配滤波

- ​	7个点的滑动平均

##### 输出波形

接收信号以及经过匹配滤波之后的信号：

![image-20210926204211959](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926204211959.png)





#### 2.2 DC Block 模块

##### 作用

- 去除直流
- 用信号能量代替信号实部，虚部为0.

##### 实现步骤

1. 计算信号部分的能量的均值：

   $energe\_avg=\left(  \sum_{k=begin}^{k=end}{(x[k].real^2+x[k].imag^2)}\right)/(end-begin)$

2. 将能量集中在实部，对于每一个输入的采样点 $x[k]$ ，输出为：

   $k\_real=(k\_real^2+k\_imag^2)-energe\_avg$

   $k\_imag=0$

##### 输出波形

匹配滤波的波形只画了实部，虚部还有信号

![image-20210926204328651](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926204328651.png)





#### 2.3 帧同步和AGC

##### 帧同步

- 帧同步使用14位preamble：（这里设计的preamble是下面的前12位，但是第一位会出错，故暂时借用数据位的两个1 ）

  `[1, -1,  1, -1, 1, -1,  1, -1, 1, -1,  1, -1,  1, 1]`

##### AGC

实现思路：

1. 计算信道估计值

2. 解决相位模糊问题（反射信号有时在载波之上，有时在载波之下）

```C
// 1. 信道估计值计算
float _channel_estimation(float * input,int index, int steps)
{
    float h = 0.0;
    for(int i = 0; i < 6; i ++){
        h += input[ index + i * steps*2 ];
    }
    return h / 6.0;
}		
int main(){
  	// index： 帧同步后的帧起始位置
  	// steps： 取值步长即 7 
  	float h_estm = _channel_estimation(input, index, steps);
  	// 2. 防止相位模糊
    if( h_estm > 0 ) { 
        for(int i = 0;  i < input_len; i++){
            input[i] = -input[i];
        }
    }
}		
```

3. 幅度调整 -- AGC

```C
		// 取信道估计值的绝对值
    h_estm = h_estm>0 ? h_estm : -h_estm;
    int out = 0;
    // 3. 幅度调整的目标值
    float agc_ampl_ref = 1.15;
    for(int i = index;  i < input_len; i++)
    {
        output[out++] =  input[i] / h_estm * agc_ampl_ref;  
    }
```

> 这种AGC的思路适用于 **已知全部前导码的值，且经过帧同步准确计算出信道估计值**的情况，在这种情况下，比之前的AGC实现更为简单且效果更好。
>
> 之前的AGC的方式优势在于：可以在不知道当前点以后的点的值的情况下，对任意当前点的值的幅度进行调整，适用于实时处理，但相应的效果没那么好。

##### 输出波形

- 下面是经过帧同步 和 AGC ==之前==和==以后==：

![image-20210926195202175](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926195202175.png)







#### 2.4 符号同步

初始时的符号同步周期为7

##### 输出波形

经过符号同步**==之前==**和**==之后==**的信号如图：

![image-20210926203110387](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926203110387.png)





#### 2.5 译码

- 直接将符号同步之后的数据 $x[k]$ 用来判决译码：

```C
if x[k] < 0
	bit[k] = 0
else 
  bit[k] = 1
```





### 3 译码性能测试结果



![image-20210926212104401](/Users/wangwen/Library/Application Support/typora-user-images/image-20210926212104401.png)







